package com.greggs.pages;import org.openqa.selenium.WebDriver;import org.openqa.selenium.WebElement;import org.openqa.selenium.support.FindBy;import org.openqa.selenium.support.PageFactory;import java.util.List;import java.util.stream.Collectors;public class MenuPage extends BasePage {    // Multiple possible selectors for menu categories    @FindBy(css = ".menu-category, [data-testid*='category'], .category, .nav-item, .category-item, .menu-item")    private List<WebElement> menuCategories;    @FindBy(css = ".menu-item, [data-testid*='item'], .product, .item, .product-item")    private List<WebElement> menuItems;    @FindBy(css = ".category-title, h2, h3, h4, .title, .heading, .product-name, .item-name")    private List<WebElement> categoryTitles;    @FindBy(css = ".item-name, .product-title, h3, h4, .name, [class*='title']")    private List<WebElement> itemNames;    @FindBy(css = ".item-price, .product-price, .price, [class*='price']")    private List<WebElement> itemPrices;    @FindBy(css = "img")    private List<WebElement> itemImages;    @FindBy(css = ".search-input, input[type='search'], [role='search'] input, #search")    private WebElement searchInput;    @FindBy(css = "a[href*='menu'], .menu-link, [data-link*='menu']")    private List<WebElement> menuLinks;    @FindBy(css = ".search-button, button[type='submit'], [aria-label*='search']")    private WebElement searchButton;    @FindBy(css = ".search-results, .results, [class*='result']")    private WebElement searchResults;    @FindBy(css = ".no-results, .empty, [class*='no-result']")    private WebElement noResultsMessage;    @FindBy(css = ".filter, [class*='filter'], .sort, [class*='sort']")    private List<WebElement> filterOptions;    public MenuPage(WebDriver driver) {        super(driver);        PageFactory.initElements(driver, this);    }    public int getCategoryCount() {        waitForPageToLoad();        return menuCategories.size();    }    public int getMenuItemCount() {        waitForPageToLoad();        return menuItems.size();    }    public int getTotalMenuItemCount() {        waitForPageToLoad();        return menuItems.size();    }    public void selectCategory(String categoryName) {        for (WebElement category : menuCategories) {            if (category.getText().toLowerCase().contains(categoryName.toLowerCase())) {                click(category);                waitForPageToLoad();                break;            }        }    }    public boolean areAllImagesLoaded() {        return !itemImages.isEmpty();    }    public boolean isPriceDisplayedForAllItems() {        return !itemPrices.isEmpty();    }    public boolean areAllItemNamesPresent() {        return !itemNames.isEmpty();    }    public boolean areAllDescriptionsPresent() {        return !menuItems.isEmpty();    }    public List<String> getCategoryTitles() {        waitForPageToLoad();        return categoryTitles.stream()                .map(WebElement::getText)                .filter(text -> !text.trim().isEmpty())                .collect(Collectors.toList());    }    public List<String> getItemNames() {        waitForPageToLoad();        return itemNames.stream()                .map(WebElement::getText)                .filter(text -> !text.trim().isEmpty())                .collect(Collectors.toList());    }    public boolean isMenuPageLoaded() {        waitForPageToLoad();        // Check if we have any menu-related elements        boolean hasMenuElements = !menuCategories.isEmpty() || !menuItems.isEmpty() || !menuLinks.isEmpty();        // Also check if URL contains "menu"        boolean urlContainsMenu = driver.getCurrentUrl().toLowerCase().contains("menu");        return hasMenuElements || urlContainsMenu;    }    public String getSelectedCategory() {        return categoryTitles.isEmpty() ? "" : categoryTitles.get(0).getText();    }    public String getPageTitle() {        return driver.getTitle();    }    public String getCurrentUrl() {        return driver.getCurrentUrl();    }    // New method to get all text content for debugging    public List<String> getAllPageText() {        waitForPageToLoad();        return driver.findElements(org.openqa.selenium.By.cssSelector("body *"))                .stream()                .map(WebElement::getText)                .filter(text -> !text.trim().isEmpty())                .filter(text -> text.length() > 2)                .distinct()                .collect(Collectors.toList());    }    // Method to check if specific food items are present    public boolean hasFoodItems() {        List<String> allText = getAllPageText();        String[] foodKeywords = {                "sausage", "roll", "bake", "sandwich", "pastry", "cake",                "coffee", "tea", "drink", "breakfast", "lunch", "snack"        };        for (String keyword : foodKeywords) {            if (allText.stream().anyMatch(text -> text.toLowerCase().contains(keyword))) {                return true;            }        }        return false;    }    // Method to get actual food categories from the page    public List<String> getActualFoodCategories() {        List<String> allText = getAllPageText();        String[] categoryKeywords = {                "sandwich", "bake", "pastry", "cake", "sweet", "savoury",                "breakfast", "lunch", "drink", "coffee", "tea", "meal",                "vegan", "vegetarian", "hot", "cold", "snack"        };        return allText.stream()                .filter(text -> {                    String lowerText = text.toLowerCase();                    for (String keyword : categoryKeywords) {                        if (lowerText.contains(keyword)) {                            return true;                        }                    }                    return false;                })                .collect(Collectors.toList());    }    // ... existing methods ...    // Search functionality methods    public boolean isSearchAvailable() {        try {            waitForPageToLoad();            return isElementPresent(searchInput) && isElementDisplayed(searchInput) && isElementEnabled(searchInput);        } catch (Exception e) {            System.err.println("Error checking search availability: " + e.getMessage());            return false;        }    }    public void searchForItem(String searchTerm) {        try {            if (isSearchAvailable()) {                System.out.println("Performing search for: " + searchTerm);                clearField(searchInput);                type(searchInput, searchTerm);                // If there's a search button, click it                if (isElementPresent(searchButton) && isElementDisplayed(searchButton)) {                    click(searchButton);                } else {                    // Otherwise, press Enter                    searchInput.sendKeys(org.openqa.selenium.Keys.ENTER);                }                // Wait for search results                waitForPageToLoad();                Thread.sleep(2000); // Additional wait for search to complete            } else {                System.out.println("Search functionality not available on this page");            }        } catch (Exception e) {            System.err.println("Error performing search: " + e.getMessage());        }    }    public boolean hasSearchResults() {        try {            waitForPageToLoad();            // Check if we have any menu items after search            boolean hasItems = getMenuItemCount() > 0;            // Also check for explicit search results container            boolean hasResultsContainer = isElementPresent(searchResults) && isElementDisplayed(searchResults);            return hasItems || hasResultsContainer;        } catch (Exception e) {            System.err.println("Error checking search results: " + e.getMessage());            return false;        }    }    public boolean hasNoResultsMessage() {        try {            waitForPageToLoad();            return isElementPresent(noResultsMessage) && isElementDisplayed(noResultsMessage);        } catch (Exception e) {            System.err.println("Error checking no results message: " + e.getMessage());            return false;        }    }    public String getNoResultsMessage() {        try {            if (hasNoResultsMessage()) {                return getElementText(noResultsMessage);            }        } catch (Exception e) {            System.err.println("Error getting no results message: " + e.getMessage());        }        return "";    }    public List<String> getSearchResults() {        try {            waitForPageToLoad();            return getItemNames(); // Reuse item names for search results        } catch (Exception e) {            System.err.println("Error getting search results: " + e.getMessage());            return List.of();        }    }    // Filter functionality methods    public void applyFilter(String filterName) {        try {            for (WebElement filter : filterOptions) {                if (getElementText(filter).toLowerCase().contains(filterName.toLowerCase())) {                    click(filter);                    waitForPageToLoad();                    break;                }            }        } catch (Exception e) {            System.err.println("Error applying filter: " + e.getMessage());        }    }    public List<String> getAvailableFilters() {        try {            return filterOptions.stream()                    .map(this::getElementText)                    .filter(text -> !text.trim().isEmpty())                    .collect(Collectors.toList());        } catch (Exception e) {            System.err.println("Error getting available filters: " + e.getMessage());            return List.of();        }    }    public boolean isFilterAvailable(String filterName) {        try {            return getAvailableFilters().stream()                    .anyMatch(filter -> filter.toLowerCase().contains(filterName.toLowerCase()));        } catch (Exception e) {            System.err.println("Error checking filter availability: " + e.getMessage());            return false;        }    }    // Enhanced search with multiple strategies    public void searchForItemWithRetry(String searchTerm, int maxRetries) {        for (int attempt = 1; attempt <= maxRetries; attempt++) {            try {                System.out.println("Search attempt " + attempt + " for: " + searchTerm);                searchForItem(searchTerm);                // Check if search produced any response                if (hasSearchResults() || hasNoResultsMessage()) {                    System.out.println("Search completed successfully");                    return;                }                if (attempt < maxRetries) {                    System.out.println("Search didn't produce results, retrying...");                    Thread.sleep(1000);                }            } catch (Exception e) {                System.err.println("Search attempt " + attempt + " failed: " + e.getMessage());                if (attempt == maxRetries) {                    throw new RuntimeException("All search attempts failed", e);                }            }        }    }    // Method to clear search    public void clearSearch() {        try {            if (isElementPresent(searchInput)) {                clearField(searchInput);                // If there's a clear button, click it                WebElement clearButton = driver.findElement(org.openqa.selenium.By.cssSelector(".clear-search, [aria-label*='clear']"));                if (isElementPresent(clearButton) && isElementDisplayed(clearButton)) {                    click(clearButton);                }                waitForPageToLoad();            }        } catch (Exception e) {            System.err.println("Error clearing search: " + e.getMessage());        }    }    // Method to get search term from input field    public String getCurrentSearchTerm() {        try {            if (isElementPresent(searchInput)) {                return getElementAttribute(searchInput, "value");            }        } catch (Exception e) {            System.err.println("Error getting current search term: " + e.getMessage());        }        return "";    }    // Method to check if search is active    public boolean isSearchActive() {        try {            String currentSearchTerm = getCurrentSearchTerm();            return !currentSearchTerm.trim().isEmpty() && (hasSearchResults() || hasNoResultsMessage());        } catch (Exception e) {            System.err.println("Error checking if search is active: " + e.getMessage());            return false;        }    }}