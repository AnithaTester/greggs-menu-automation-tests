package com.greggs.tests.specs;import com.aventstack.extentreports.ExtentTest;import com.greggs.pages.MenuPage;import com.greggs.tests.BaseTest;import org.openqa.selenium.By;import org.openqa.selenium.WebElement;import org.testng.annotations.Test;import java.util.HashMap;import java.util.List;import java.util.Map;@Test(groups = {"data", "regression", "menu", "count"})public class MenuItemCountSpec extends BaseTest {    @Test(description = "Verify menu has reasonable number of items", groups = {"data", "menu", "count", "smoke"})    public void testMenuItemCount() {        ExtentTest currentTest = initializeTest("testMenuItemCount", "data", "menu", "count", "smoke");        try {            logInfo("Starting menu item count analysis");            navigateToMenuPage();            MenuPage menuPage = new MenuPage(driver);            List<String> itemNames = menuPage.getItemNames();            int itemCount = itemNames.size();            logInfo("Total menu items found: " + itemCount);            // Enhanced count validation            if (itemCount == 0) {                currentTest.warning("No specific menu items found - checking alternative content");                checkAlternativeContent(currentTest);            } else if (itemCount >= 5) {                currentTest.pass("GOOD: Menu contains " + itemCount + " items - adequate selection");                // Log sample items                if (!itemNames.isEmpty()) {                    currentTest.info("Sample items: " +                            String.join(", ", itemNames.subList(0, Math.min(3, itemNames.size()))));                }            } else if (itemCount >= 2) {                currentTest.pass("BASIC: Menu contains " + itemCount + " items - minimal but functional");            } else {                currentTest.warning("LIMITED: Only " + itemCount + " menu items found");            }            // Quality check - ensure no empty items            int emptyItems = countEmptyItems(itemNames);            if (emptyItems == 0) {                currentTest.pass("QUALITY: All menu items have valid names");            } else {                currentTest.warning("QUALITY ISSUE: " + emptyItems + " empty menu items found");            }            markTestPassed("Menu item count test COMPLETED", currentTest);        } catch (Exception e) {            handleTestFailure(e, currentTest);        }    }    @Test(description = "Verify menu categories have reasonable item distribution", groups = {"data", "menu", "count", "distribution"})    public void testMenuCategoryDistribution() {        ExtentTest currentTest = initializeTest("testMenuCategoryDistribution", "data", "menu", "count", "distribution");        try {            logInfo("Starting menu category distribution analysis");            navigateToMenuPage();            // Use alternative method to analyze categories            Map<String, Integer> categoryDistribution = analyzeCategoriesManually();            int categoryCount = categoryDistribution.size();            logInfo("Categories found: " + categoryCount);            if (categoryDistribution.isEmpty()) {                currentTest.info("No explicit categories found - analyzing overall structure");                analyzeMenuStructure(currentTest);            } else {                // Analyze distribution                analyzeCategoryDistribution(categoryDistribution, currentTest);            }            markTestPassed("Menu category distribution test COMPLETED", currentTest);        } catch (Exception e) {            handleTestFailure(e, currentTest);        }    }    @Test(description = "Verify menu item density and content richness", groups = {"data", "menu", "count", "quality"})    public void testMenuItemDensity() {        ExtentTest currentTest = initializeTest("testMenuItemDensity", "data", "menu", "count", "quality");        try {            logInfo("Starting menu item density analysis");            navigateToMenuPage();            MenuPage menuPage = new MenuPage(driver);            List<String> allTextElements = menuPage.getAllPageText();            List<String> itemNames = menuPage.getItemNames();            int totalElements = allTextElements.size();            int itemCount = itemNames.size();            logInfo("Total page elements: " + totalElements);            logInfo("Menu items: " + itemCount);            // Calculate density metrics            double itemDensity = totalElements > 0 ? (double) itemCount / totalElements : 0;            logInfo("Item density ratio: " + String.format("%.2f", itemDensity));            if (itemDensity > 0.3) {                currentTest.pass("HIGH DENSITY: Good menu item concentration (" +                        String.format("%.1f", itemDensity * 100) + "%)");            } else if (itemDensity > 0.1) {                currentTest.pass("MODERATE DENSITY: Reasonable menu item concentration (" +                        String.format("%.1f", itemDensity * 100) + "%)");            } else {                currentTest.warning("LOW DENSITY: Limited menu item concentration (" +                        String.format("%.1f", itemDensity * 100) + "%)");            }            // Content richness check            checkContentRichness(allTextElements, itemCount, currentTest);            markTestPassed("Menu item density test COMPLETED", currentTest);        } catch (Exception e) {            handleTestFailure(e, currentTest);        }    }    @Test(description = "Verify menu sections and grouping", groups = {"data", "menu", "count", "organization"})    public void testMenuOrganization() {        ExtentTest currentTest = initializeTest("testMenuOrganization", "data", "menu", "count", "organization");        try {            logInfo("Starting menu organization analysis");            navigateToMenuPage();            // Analyze menu sections and grouping            Map<String, Object> organizationAnalysis = analyzeMenuOrganization();            int sectionCount = (Integer) organizationAnalysis.get("sectionCount");            int groupCount = (Integer) organizationAnalysis.get("groupCount");            boolean hasStructure = (Boolean) organizationAnalysis.get("hasStructure");            logInfo("Sections found: " + sectionCount);            logInfo("Groups found: " + groupCount);            logInfo("Has organized structure: " + hasStructure);            if (hasStructure) {                currentTest.pass("ORGANIZED: Menu has clear section structure");                if (sectionCount >= 2) {                    currentTest.pass("WELL-STRUCTURED: Multiple sections (" + sectionCount + ") for better organization");                }            } else {                currentTest.info("FLAT STRUCTURE: Menu appears as a single section");            }            markTestPassed("Menu organization test COMPLETED", currentTest);        } catch (Exception e) {            handleTestFailure(e, currentTest);        }    }    // ========== HELPER METHODS ==========    private ExtentTest initializeTest(String testName, String... categories) {        ExtentTest currentTest = getTest();        if (currentTest == null) {            currentTest = extent.createTest(testName);        }        currentTest.assignCategory(categories);        return currentTest;    }    private int countEmptyItems(List<String> itemNames) {        return (int) itemNames.stream()                .filter(item -> item == null || item.trim().isEmpty())                .count();    }    private void checkAlternativeContent(ExtentTest currentTest) {        try {            MenuPage menuPage = new MenuPage(driver);            List<String> allText = menuPage.getAllPageText();            logInfo("Alternative content analysis - Total text elements: " + allText.size());            // Check for food-related content            long foodRelated = allText.stream()                    .filter(text -> text != null &&                            text.toLowerCase().matches(".*\\b(sausage|roll|sandwich|pastry|cake|bread|coffee|tea|menu)\\b.*"))                    .count();            if (foodRelated > 0) {                currentTest.info("Found " + foodRelated + " food-related text elements");            }        } catch (Exception e) {            currentTest.info("Alternative content analysis incomplete");        }    }    private Map<String, Integer> analyzeCategoriesManually() {        Map<String, Integer> categoryDistribution = new HashMap<>();        try {            // Look for common category patterns in the page            List<WebElement> categoryElements = driver.findElements(By.cssSelector(                    "[class*='category'], [class*='menu-'], [class*='section'], h2, h3, .heading, .title"            ));            for (WebElement element : categoryElements) {                try {                    String text = element.getText().trim();                    if (!text.isEmpty() && text.length() < 50) { // Reasonable category name length                        String category = text;                        // Estimate item count under this category                        int itemCount = estimateItemsUnderCategory(element);                        categoryDistribution.put(category, itemCount);                    }                } catch (Exception e) {                    // Continue with next element                }            }        } catch (Exception e) {            logWarning("Error analyzing categories manually: " + e.getMessage());        }        return categoryDistribution;    }    private int estimateItemsUnderCategory(WebElement categoryElement) {        try {            // Try to find list items or product elements near this category            List<WebElement> nearbyItems = categoryElement.findElements(By.xpath(                    "following-sibling::ul//li | following-sibling::div[contains(@class, 'item')] | " +                            "following-sibling::div[contains(@class, 'product')]"            ));            return nearbyItems.size();        } catch (Exception e) {            return 0;        }    }    private void analyzeCategoryDistribution(Map<String, Integer> distribution, ExtentTest currentTest) {        int totalItems = distribution.values().stream().mapToInt(Integer::intValue).sum();        int categoryCount = distribution.size();        logInfo("Total items across categories: " + totalItems);        logInfo("Number of categories: " + categoryCount);        double avgItemsPerCategory = (double) totalItems / categoryCount;        currentTest.info("Average items per category: " + String.format("%.1f", avgItemsPerCategory));        // Check distribution balance        int minItems = distribution.values().stream().mapToInt(Integer::intValue).min().orElse(0);        int maxItems = distribution.values().stream().mapToInt(Integer::intValue).max().orElse(0);        currentTest.info("Category size range: " + minItems + " - " + maxItems + " items");        if (minItems > 0) {            currentTest.pass("BALANCED: All categories contain items");        }        if (maxItems - minItems <= 5) {            currentTest.pass("EVEN: Category sizes are reasonably balanced");        } else {            currentTest.info("VARIED: Category sizes show significant variation");        }        // Log category details (limit to top 5 to avoid clutter)        distribution.entrySet().stream()                .limit(5)                .forEach(entry -> {                    currentTest.info("Category '" + entry.getKey() + "': " + entry.getValue() + " items");                });        if (distribution.size() > 5) {            currentTest.info("... and " + (distribution.size() - 5) + " more categories");        }    }    private void analyzeMenuStructure(ExtentTest currentTest) {        try {            MenuPage menuPage = new MenuPage(driver);            List<String> allText = menuPage.getAllPageText();            logInfo("Menu structure analysis - Total elements: " + allText.size());            // Look for structural patterns (headings, titles, etc.)            long headingLike = allText.stream()                    .filter(text -> text != null &&                            (text.length() < 50 &&                                    (Character.isUpperCase(text.charAt(0)) ||                                            text.matches(".*[A-Z].*"))))                    .count();            if (headingLike > 3) {                currentTest.info("Found " + headingLike + " potential category headings");            }            // Check for list structures            int listCount = driver.findElements(By.tagName("ul")).size() +                    driver.findElements(By.tagName("ol")).size();            currentTest.info("List structures found: " + listCount);        } catch (Exception e) {            currentTest.info("Menu structure analysis incomplete");        }    }    private void checkContentRichness(List<String> allText, int itemCount, ExtentTest currentTest) {        // Calculate average text length        double avgLength = allText.stream()                .filter(text -> text != null && !text.trim().isEmpty())                .mapToInt(String::length)                .average()                .orElse(0);        logInfo("Average text element length: " + String.format("%.1f", avgLength));        if (avgLength > 20) {            currentTest.pass("RICH CONTENT: Substantial descriptive text");        } else if (avgLength > 10) {            currentTest.pass("ADEQUATE CONTENT: Reasonable text descriptions");        } else {            currentTest.info("CONCISE CONTENT: Brief text elements");        }        // Check for variety in content        long uniqueElements = allText.stream()                .filter(text -> text != null && !text.trim().isEmpty())                .distinct()                .count();        double uniquenessRatio = allText.size() > 0 ? (double) uniqueElements / allText.size() : 0;        if (uniquenessRatio > 0.8) {            currentTest.pass("HIGH VARIETY: Diverse content elements");        }    }    private Map<String, Object> analyzeMenuOrganization() {        Map<String, Object> analysis = new HashMap<>();        try {            // Look for sections and groups            int sectionCount = driver.findElements(By.cssSelector("section, [class*='section'], [class*='menu-']")).size();            int groupCount = driver.findElements(By.cssSelector("[class*='group'], [class*='category'], .row, .column")).size();            analysis.put("sectionCount", sectionCount);            analysis.put("groupCount", groupCount);            analysis.put("hasStructure", sectionCount > 0 || groupCount > 0);        } catch (Exception e) {            analysis.put("sectionCount", 0);            analysis.put("groupCount", 0);            analysis.put("hasStructure", false);        }        return analysis;    }}